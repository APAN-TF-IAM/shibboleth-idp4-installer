<?xml version="1.0" encoding="UTF-8"?>
<AttributeResolver
        xmlns="urn:mace:shibboleth:2.0:resolver" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:schemaLocation="urn:mace:shibboleth:2.0:resolver http://shibboleth.net/schema/idp/shibboleth-attribute-resolver.xsd">

    <!-- ========================================== -->
    <!--         The User's ID - UID                -->
    <!-- ========================================== -->
 
    <!-- Option 1: Using the subject's canonicalized principal name -->

    <AttributeDefinition id="uid" xsi:type="PrincipalName" />
       
    <!-- ========================================== -->
    <!--         AAF CORE ATTRIBUTES                -->
    <!-- ========================================== -->

    <!-- auEduPersonSharedToken -->
    <AttributeDefinition id="auEduPersonSharedToken" xsi:type="Simple">
        <InputDataConnector ref="sharedToken" attributeNames="auEduPersonSharedToken"/>
    </AttributeDefinition>
    -->

    <!-- displayName -->
    <!-- Provided via exportAttributes in the ldap data connector -->

    <!-- eduPersonAffiliation -->
    <AttributeDefinition xsi:type="ScriptedAttribute" id="eduPersonAffiliation">
        <InputDataConnector ref="ldap" attributeNames="eduPersonAffiliation" />
        <Script><![CDATA[
            var HashSet = Java.type("java.util.HashSet");
            var StringAttributeValue = Java.type("net.shibboleth.idp.attribute.StringAttributeValue");
            var newAffiliations = new HashSet();

            add_member = false;

            if (typeof eduPersonAffiliation != "undefined" && eduPersonAffiliation.getValues().size() >= 1) {
                for ( i = 0; i < eduPersonAffiliation.getValues().size(); i++){
                    value = eduPersonAffiliation.getValues().get(i).toLowerCase();
                    if (value.equals("affiliate") ||
                        value.equals("alum") ||
                        value.equals("member") ||
                        value.equals("library-walk-in")) {
                        newAffiliations.add(new StringAttributeValue(value));
                    }
                    if (value.equals("student") ||
                        value.equals("faculty") ||
                        value.equals("staff") ||
                        value.equals("employee")) {
                        newAffiliations.add(new StringAttributeValue(value));
                        add_member = true;
                    }
                }
            }
      
            if (add_member) { newAffiliations.add(new StringAttributeValue("member")); }
      
            if (newAffiliations.size() < 1) {
                newAffiliations.add(new StringAttributeValue("affiliate"));
            }

            eduPersonAffiliation.getValues().clear();

            itr = newAffiliations.iterator();
            while(itr.hasNext()){
               eduPersonAffiliation.addValue(itr.next());
            }
        ]]></Script>
    </AttributeDefinition>


    <AttributeDefinition xsi:type="Simple" id="displayName">
        <InputDataConnector ref="ldap" attributeNames="displayName" />
    </AttributeDefinition>


    <!-- ========================================== -->
    <!--      Attribute Definitions                 -->
    <!-- ========================================== -->

    <!--
    The EPPN is the "standard" federated username in higher ed.
    For guidelines on the implementation of this attribute, refer
    to the Shibboleth and eduPerson documentation. Above all, do
    not expose a value for this attribute without considering the
    long term implications. 
    -->
    <AttributeDefinition id="eduPersonPrincipalName" xsi:type="Scoped" scope="%{idp.scope}">
        <InputAttributeDefinition ref="uid" />
    </AttributeDefinition>

    <!--
    The uid is the closest thing to a "standard" LDAP attribute
    representing a local username, but you should generally *never*
    expose uid to federated services, as it is rarely globally unique.
    -->
    <AttributeDefinition id="uid" xsi:type="PrincipalName" />

    <!--
    In the rest of the world, the email address is the standard identifier,
    despite the problems with that practice. Consider making the EPPN
    value the same as your official email addresses whenever possible.
    -->
    <!-- ========================================== -->
    <!--      Data Connectors                       -->
    <!-- ========================================== -->

    <DataConnector id="staticAttributes" xsi:type="Static">
        <Attribute id="affiliation">
            <Value>member</Value>
        </Attribute>
    </DataConnector>

    <DataConnector id="ldap" xsi:type="LDAPDirectory"
        ldapURL="%{idp.attribute.resolver.LDAP.ldapURL}"
        baseDN="%{idp.attribute.resolver.LDAP.baseDN}"
        principal="%{idp.attribute.resolver.LDAP.bindDN}"
        principalCredential="%{idp.attribute.resolver.LDAP.bindDNCredential}"
        useStartTLS="%{idp.attribute.resolver.LDAP.useStartTLS:true}"
        connectTimeout="%{idp.attribute.resolver.LDAP.connectTimeout}"
        responseTimeout="%{idp.attribute.resolver.LDAP.responseTimeout}"
        exportAttributes="displayName">
        <FilterTemplate>
            <![CDATA[
                %{idp.attribute.resolver.LDAP.searchFilter}
            ]]>
        </FilterTemplate>
        <ConnectionPool
            minPoolSize="%{idp.pool.LDAP.minSize:3}"
            maxPoolSize="%{idp.pool.LDAP.maxSize:10}"
            blockWaitTime="%{idp.pool.LDAP.blockWaitTime:PT3S}"
            validatePeriodically="%{idp.pool.LDAP.validatePeriodically:true}"
            validateTimerPeriod="%{idp.pool.LDAP.validatePeriod:PT5M}"
            validateDN="%{idp.pool.LDAP.validateDN:}"
            validateFilter="%{idp.pool.LDAP.validateFilter:(objectClass=*)}"
            expirationTime="%{idp.pool.LDAP.idleTime:PT10M}"/>
    </DataConnector>

<!--
    <resolver:DataConnector xsi:type="SharedToken" xmlns="urn:mace:aaf.edu.au:shibboleth:2.0:resolver:dc"
        id="sharedToken"
        sourceAttributeId="uid"
        salt="{{ shib_idp.aepst_salt }}"
        dataSource="shibboleth.JPAStorageService.DataSource">
        <resolver:Dependency ref="uid" />
    </resolver:DataConnector>
-->

</AttributeResolver>
